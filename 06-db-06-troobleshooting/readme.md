# Задача 1
Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её нужно прервать.  
Вы как инженер поддержки решили произвести данную операцию:  
Для поиска долгой операции выполним: 'db.currentOp()'. 
Он вернет информацию обо всех активных операциях, выполняемых сервере MongoDB. Это позволяет быстро идентифицировать длительные и / или блокирующие операции.  
Для завершения операции необходимо выполнить команду: 'db.killOp()'.  
Эта команда принимает на вход ID операции (можно получить при выполнении 'db.currentOp()') и завешает эту операцию.  

предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB  
В качестве решения проблемы с долгими запросами можно посмтроить / перестроить индексы, вертифкально или горизонтально масштабировать кластер. Надо разобраться почему операция зависает: Большой объём данных, сложные или неоптимальные запросы или есть блокирующие операции.  

# Задача 2
При масштабировании сервиса до N реплик вы увидели, что:  
* сначала рост отношения записанных значений к истекшим  
* Redis блокирует операции записи  
Как вы думаете, в чем может быть проблема?  
Т.к. сервис используется функцией TTL в Redis, то в базе остаютзя записи, которые необходимо удалять. В Redis существует 2 метода удаления устаревших записей активный и ленивый.  
Ленивый способ - ленивый метод удаляет устаревшие записи по запросу.
Активный способ - удаляет устаревшие записи каждые 100 мс.
Исходя из условий задачи - можно сделать вывод, что в базе накопилось много устаревших записей redis не успевает их удалять. По этой же причине Redis заблокировал операции записи.  

# Задача 3
Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы, пользователи начали жаловаться на ошибки вида:
```
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
```
Как вы думаете, почему это начало происходить и как локализовать проблему?  
Какие пути решения данной проблемы вы можете предложить?  
Эти ошибки могут возникать из-за проблем с производительностью СУБД. Из условий задания мы можем сделать вывод, что проблема возникает при увеличении числа записей в БД. Необходимо проверить производительность СУБД, проверить лог сервера на предмет ошибок, предупреждений.
Решением в текущей ситуации могут быть:
  1. Увеличить значение параметров СУБД: connect_timeout, interactive_timeout, wait_timeout
  2. Вертикальном или горизонтальное масштабирование кластера СУБД
  3. Найти долгие запросы, создать индексы, передать подробности инцидента разработчикам для устранения на стороне приложения.
  4. Проверить ошибки на уровне сети. Такая ошибка может свидетельствовать о недостаточном значении таймаутов при обращении к СУБД (пример net_read_timeout,wait_timeout)

# Задача 4
После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:  
postmaster invoked oom-killer  
Как вы думаете, что происходит?  
Как бы вы решили данную проблему?  

Причина в недостаточном объёме оперативной памяти, в ОС существует процесс oom-killer, который завершает процессы утилизирующие память, чтобы предотвратить падение всей системы. Для предотвращения сбоев, необходимо увеличить объем ОЗУ. Также можно в файле конфигурации postgresql установить максимальное значение оперативной памяти, которое будет доступно для сервера СУБД.  
Также необходимо проверить лог событий postgresql, чтобы понять нет ли ошибок в конфигурации сервера СУБД.  
